/*
 * Late API
 *
 * API reference for Late. Authenticate with a Bearer API key. Base URL: https://getlate.dev/api
 *
 * The version of the OpenAPI document: 1.0.1
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`get_analytics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAnalyticsError {
    Status401(models::InlineObject),
    Status402(models::GetAnalytics402Response),
    Status404(models::InlineObject1),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_follower_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFollowerStatsError {
    Status401(models::InlineObject),
    Status403(models::GetFollowerStats403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_linked_in_aggregate_analytics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLinkedInAggregateAnalyticsError {
    Status400(models::GetLinkedInAggregateAnalytics400Response),
    Status401(models::InlineObject),
    Status402(models::GetLinkedInAggregateAnalytics402Response),
    Status403(models::GetLinkedInAggregateAnalytics403Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_linked_in_post_analytics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLinkedInPostAnalyticsError {
    Status400(models::GetLinkedInPostAnalytics400Response),
    Status401(models::InlineObject),
    Status402(),
    Status403(models::GetLinkedInPostAnalytics403Response),
    Status404(models::GetLinkedInAggregateAnalytics402Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_you_tube_daily_views`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetYouTubeDailyViewsError {
    Status400(models::GetYouTubeDailyViews400Response),
    Status401(models::InlineObject),
    Status402(models::GetAnalytics402Response),
    Status403(models::GetYouTubeDailyViews403Response),
    Status412(models::YouTubeScopeMissingResponse),
    Status500(models::GetYouTubeDailyViews500Response),
    UnknownValue(serde_json::Value),
}

/// Returns analytics for posts. If postId is provided, returns analytics for a single post. Otherwise returns a paginated list of posts with overview stats.  **Important: Understanding Post IDs**  This endpoint uses two types of posts: - **Late Posts** - Posts scheduled/created via the Late API (e.g., via `POST /v1/posts`) - **External Posts** - Posts synced from social platforms for analytics tracking  When you schedule a post via Late and it gets published, **both** records exist: 1. The original Late Post (returned when you created the post) 2. An External Post (created when we sync analytics from the platform)  **List endpoint behavior:** - Returns External Post IDs (`_id` field) - Use the `isExternal` field to identify post origin:   - `isExternal: true` - Synced from platform (may have been originally scheduled via Late)   - `isExternal: false` - Late-scheduled post (shown when querying by Late post ID)  **Single post behavior (`postId` parameter):** - Accepts **both** Late Post IDs and External Post IDs - If you pass a Late Post ID, the API automatically resolves it to the corresponding External Post analytics - Both return the same analytics data for the same underlying social media post  **Correlating posts:** Use `latePostId` to link analytics entries back to the original post created via `POST /v1/posts`. This field contains the Late Post ID when the external post originated from Late. Alternatively, use `platformPostUrl` (e.g., `https://www.instagram.com/reel/ABC123/`) as a stable identifier.  **Note:** For follower count history and growth metrics, use the dedicated `/v1/accounts/follower-stats` endpoint.  **LinkedIn Analytics:** - **Personal Accounts:** Per-post analytics available for posts published through Late. External posts cannot be synced due to LinkedIn API restrictions. - **Organization Accounts:** Full analytics support including external post syncing.  **Telegram Analytics:** - **Not available.** The Telegram Bot API does not provide message view counts, forwards, or engagement metrics. This is a Telegram platform limitation, not a Late limitation. View counts are only visible to channel admins in the Telegram app.  **Data Freshness:** Analytics data is cached and refreshed at most once per hour. When you call this endpoint, if the cache is older than 60 minutes, a background refresh is triggered and you'll see updated data on subsequent requests. There is no rate limit on API requests.
pub async fn get_analytics(
    configuration: &configuration::Configuration,
    post_id: Option<&str>,
    platform: Option<&str>,
    profile_id: Option<&str>,
    source: Option<&str>,
    from_date: Option<String>,
    to_date: Option<String>,
    limit: Option<i32>,
    page: Option<i32>,
    sort_by: Option<&str>,
    order: Option<&str>,
) -> Result<models::GetAnalytics200Response, Error<GetAnalyticsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_post_id = post_id;
    let p_query_platform = platform;
    let p_query_profile_id = profile_id;
    let p_query_source = source;
    let p_query_from_date = from_date;
    let p_query_to_date = to_date;
    let p_query_limit = limit;
    let p_query_page = page;
    let p_query_sort_by = sort_by;
    let p_query_order = order;

    let uri_str = format!("{}/v1/analytics", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_post_id {
        req_builder = req_builder.query(&[("postId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_profile_id {
        req_builder = req_builder.query(&[("profileId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_source {
        req_builder = req_builder.query(&[("source", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_from_date {
        req_builder = req_builder.query(&[("fromDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_to_date {
        req_builder = req_builder.query(&[("toDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by {
        req_builder = req_builder.query(&[("sortBy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAnalytics200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAnalytics200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAnalyticsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns follower count history and growth metrics for connected social accounts. **Requires analytics add-on subscription.**  **Data Freshness:** Follower counts are automatically refreshed once per day.
pub async fn get_follower_stats(
    configuration: &configuration::Configuration,
    account_ids: Option<&str>,
    profile_id: Option<&str>,
    from_date: Option<String>,
    to_date: Option<String>,
    granularity: Option<&str>,
) -> Result<models::GetFollowerStats200Response, Error<GetFollowerStatsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_ids = account_ids;
    let p_query_profile_id = profile_id;
    let p_query_from_date = from_date;
    let p_query_to_date = to_date;
    let p_query_granularity = granularity;

    let uri_str = format!("{}/v1/accounts/follower-stats", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_account_ids {
        req_builder = req_builder.query(&[("accountIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_profile_id {
        req_builder = req_builder.query(&[("profileId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_from_date {
        req_builder = req_builder.query(&[("fromDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_to_date {
        req_builder = req_builder.query(&[("toDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_granularity {
        req_builder = req_builder.query(&[("granularity", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetFollowerStats200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetFollowerStats200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFollowerStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns aggregate analytics across ALL posts for a LinkedIn personal account. Uses LinkedIn's `memberCreatorPostAnalytics` API with `q=me` finder.  **Important:** This endpoint only works for LinkedIn **personal** accounts. Organization accounts should use the standard `/v1/analytics` endpoint for per-post analytics.  **Required Scope:** `r_member_postAnalytics`  If the connected account doesn't have this scope, you'll receive a 403 error with instructions to reconnect.  **Aggregation Options:** - `TOTAL` (default): Returns lifetime totals for all metrics - `DAILY`: Returns daily breakdown of metrics over time  **Available Metrics:** - `IMPRESSION`: Number of times posts were displayed - `MEMBERS_REACHED`: Unique members who saw posts (NOT available with DAILY aggregation) - `REACTION`: Total reactions (likes, celebrates, etc.) - `COMMENT`: Total comments - `RESHARE`: Total reshares/reposts  **Date Range Filtering:** Use `startDate` and `endDate` parameters to filter analytics to a specific time period. If omitted, returns lifetime analytics.  **LinkedIn API Limitation:** The combination of `MEMBERS_REACHED` + `DAILY` aggregation is not supported by LinkedIn's API.
pub async fn get_linked_in_aggregate_analytics(
    configuration: &configuration::Configuration,
    account_id: &str,
    aggregation: Option<&str>,
    start_date: Option<String>,
    end_date: Option<String>,
    metrics: Option<&str>,
) -> Result<
    models::GetLinkedInAggregateAnalytics200Response,
    Error<GetLinkedInAggregateAnalyticsError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_account_id = account_id;
    let p_query_aggregation = aggregation;
    let p_query_start_date = start_date;
    let p_query_end_date = end_date;
    let p_query_metrics = metrics;

    let uri_str = format!(
        "{}/v1/accounts/{accountId}/linkedin-aggregate-analytics",
        configuration.base_path,
        accountId = crate::apis::urlencode(p_path_account_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_aggregation {
        req_builder = req_builder.query(&[("aggregation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("startDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("endDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_metrics {
        req_builder = req_builder.query(&[("metrics", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetLinkedInAggregateAnalytics200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetLinkedInAggregateAnalytics200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLinkedInAggregateAnalyticsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns analytics for a specific LinkedIn post using its URN. Works for both personal and organization accounts.  This is useful for fetching analytics of posts that weren't published through Late, as long as you have the post URN.  **For Personal Accounts:** - Uses `memberCreatorPostAnalytics` API + `memberCreatorVideoAnalytics` for video posts - Requires `r_member_postAnalytics` scope - Available metrics: impressions, reach, likes, comments, shares, video views (video posts only) - **Clicks are NOT available** for personal accounts  **For Organization Accounts:** - Uses `organizationalEntityShareStatistics` API + `videoAnalytics` for video posts - Requires `r_organization_social` scope - Available metrics: impressions, reach, clicks, likes, comments, shares, video views (video posts only), engagement rate
pub async fn get_linked_in_post_analytics(
    configuration: &configuration::Configuration,
    account_id: &str,
    urn: &str,
) -> Result<models::GetLinkedInPostAnalytics200Response, Error<GetLinkedInPostAnalyticsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_account_id = account_id;
    let p_query_urn = urn;

    let uri_str = format!(
        "{}/v1/accounts/{accountId}/linkedin-post-analytics",
        configuration.base_path,
        accountId = crate::apis::urlencode(p_path_account_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("urn", &p_query_urn.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetLinkedInPostAnalytics200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetLinkedInPostAnalytics200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLinkedInPostAnalyticsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns historical daily view counts for a specific YouTube video. Uses YouTube Analytics API v2 to fetch daily breakdowns including views, watch time, and subscriber changes.  **Required Scope:** This endpoint requires the `yt-analytics.readonly` OAuth scope. Existing YouTube accounts may need to re-authorize to grant this permission. If the scope is missing, the response will include a `reauthorizeUrl`.  **Data Latency:** YouTube Analytics data has a 2-3 day delay. The `endDate` is automatically capped to 3 days ago.  **Date Range:** Maximum 90 days of historical data available. Defaults to last 30 days.
pub async fn get_you_tube_daily_views(
    configuration: &configuration::Configuration,
    video_id: &str,
    account_id: &str,
    start_date: Option<String>,
    end_date: Option<String>,
) -> Result<models::YouTubeDailyViewsResponse, Error<GetYouTubeDailyViewsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_video_id = video_id;
    let p_query_account_id = account_id;
    let p_query_start_date = start_date;
    let p_query_end_date = end_date;

    let uri_str = format!(
        "{}/v1/analytics/youtube/daily-views",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("videoId", &p_query_video_id.to_string())]);
    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("startDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("endDate", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::YouTubeDailyViewsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::YouTubeDailyViewsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetYouTubeDailyViewsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
